#include "EntityROV.h"

MaterialData getMaterialData()
{
	MaterialData material;
	material.model = "./res/models/rov.obj";
	material.vertexShader = "./res/shaders/shader.vert";
	material.fragmentShader = "./res/shaders/shader.frag";
	material.albedo = "./res/textures/rov_body.png";

	return material;
}

EntityROV::EntityROV(const RovSetup& setup) :
	EntityRigidBody(getMaterialData(), setup.mass, &setup.centerOfMass),
	m_thrusterPower(setup.maxThrsuterPower)
{
	//Set location and rotation of the ROV
	for (int i = 0; i < THRUSTER_COUNT; ++i)
	{
		quaternion rot = quaternion(glm::vec3(1, 0, 0), setup.thrusterRotations[i].x) *
						 quaternion(glm::vec3(0, 1, 0), setup.thrusterRotations[i].y) *
						 quaternion(glm::vec3(0, 0, 1), setup.thrusterRotations[i].z);

		m_thrusterPositions[i] = { setup.thrusterPositions[i], rot, setup.thrusterPower[i] };
	}

	m_transform.position(setup.position);
	m_transform.rotation(quaternion(glm::vec3(1, 0, 0), setup.rotation.x) *
						 quaternion(glm::vec3(0, 1, 0), setup.rotation.y) *
						 quaternion(glm::vec3(0, 0, 1), setup.rotation.z));

	//Create thruster entities
	MaterialData thrusterMaterial;
	thrusterMaterial.model = "./res/models/thruster.obj";
	thrusterMaterial.vertexShader = "./res/shaders/shader.vert";
	thrusterMaterial.fragmentShader = "./res/shaders/shader.frag";
	thrusterMaterial.albedo = "./res/textures/thruster.png";

	for(int i = 0; i < THRUSTER_COUNT; ++i)
	{
		m_entityThrusters[i] = new EntityObject(thrusterMaterial);
		m_entityThrusters[i]->getTransform().position(std::get<0>(m_thrusterPositions[i]));
		m_entityThrusters[i]->getTransform().rotation(std::get<1>(m_thrusterPositions[i]));
		m_entityThrusters[i]->getTransform().scale(glm::vec3(0.1f, 0.1f, 0.1f));

		m_entityThrusters[i]->setParent(this);
	}

	//Create camera entities
	for (size_t i = 0; i < setup.cameras.size(); ++i)
	{
		ROVCameraSetup camSetup = setup.cameras[i];
		EntityCamera* camera = new EntityCamera((int)camSetup.resolution.x, (int)camSetup.resolution.y, camSetup.fov, camSetup.port, camSetup.quality);
		camera->getTransform().position(camSetup.position);
		camera->getTransform().rotation(quaternion({ 1.0f, 0.0f, 0.0f }, camSetup.rotation.x) *
										quaternion({ 0.0f, 1.0f, 0.0f }, camSetup.rotation.y) *
										quaternion({ 0.0f, 0.0f, 1.0f }, camSetup.rotation.z));

		camera->setParent(this);

		m_entityCameras.push_back(camera);
	}
}

EntityROV::~EntityROV()
{
	for (int i = 0; i < THRUSTER_COUNT; ++i)
	{
		delete m_entityThrusters[i];
	}

	for (size_t i = 0; i < m_entityCameras.size(); ++i)
	{
		delete m_entityCameras[i];
	}
}

void EntityROV::update(double delta)
{
	//Add forces generated by thrusters
	for (size_t i = 0; i < THRUSTER_COUNT; ++i)
	{
		glm::vec3 force = std::get<2>(m_thrusterPositions[i]) * std::get<1>(m_thrusterPositions[i]).localRotate(glm::vec3(0, 1, 0));
		addForceLocal(std::get<0>(m_thrusterPositions[i]), force);
	}

	//Update 
	EntityRigidBody::update(delta);

	for (size_t i = 0; i < THRUSTER_COUNT; ++i)
	{
		m_entityThrusters[i]->update(delta);
	}
}

void EntityROV::render(RenderingEngine& renderer)
{
	EntityRigidBody::render(renderer);

	for (int i = 0; i < THRUSTER_COUNT; ++i)
	{
		m_entityThrusters[i]->render(renderer);
	}

	for (size_t i = 0; i < m_entityCameras.size(); ++i)
	{
		m_entityCameras[i]->render(renderer);
	}
}

void EntityROV::renderFinished()
{
	for (size_t i = 0; i < m_entityCameras.size(); ++i)
	{
		m_entityCameras[i]->renderFinished();
	}
}